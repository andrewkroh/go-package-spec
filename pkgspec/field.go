// Code generated by cmd/generate; DO NOT EDIT.

package pkgspec

import yamlv3 "gopkg.in/yaml.v3"

// Field represents a field definition in a data stream's field mapping.
type Field struct {
	FileMetadata `json:"-" yaml:"-"`
	// Name of the analyzer to use for indexing. Unless search_analyzer is specified this analyzer is
	// used for both indexing and searching. Only valid for 'type: text'.
	Analyzer string `json:"analyzer,omitempty" yaml:"analyzer,omitempty"`
	// The copy_to parameter allows you to copy the values of multiple fields into a group field, which
	// can then be queried as a single field.
	CopyTo string `json:"copy_to,omitempty" yaml:"copy_to,omitempty"`
	// The date format(s) that can be parsed. Type date format default to
	// `strict_date_optional_time||epoch_millis`, see the [doc]. In JSON documents, dates are
	// represented as strings. Elasticsearch uses a set of preconfigured formats to recognize and parse
	// these strings into a long value representing _milliseconds-since-the-epoch_ in UTC. Besides the
	// [built-in formats], your own [custom formats] can be specified using the familiar `yyyy/MM/dd`
	// syntax.
	//
	// [doc]: https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html#date-params
	// [built-in formats]: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#built-in-date-formats
	// [custom formats]: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html#custom-date-formats
	DateFormat    string `json:"date_format,omitempty" yaml:"date_format,omitempty"`
	DefaultMetric any    `json:"default_metric,omitempty" yaml:"default_metric,omitempty"`
	// Short description of field
	Description string `json:"description,omitempty" yaml:"description,omitempty"`
	// Declare a field as dimension of time series. This is attached to the field as a
	// `time_series_dimension` mapping parameter.
	Dimension *bool `json:"dimension,omitempty" yaml:"dimension,omitempty"`
	// Controls whether doc values are enabled for a field. All fields which support doc values have
	// them enabled by default. If you are sure that you don’t need to sort or aggregate on a field,
	// or access the field value from a script, you can disable doc values in order to save disk space.
	// You cannot disable doc values for wildcard fields.
	DocValues *bool `json:"doc_values,omitempty" yaml:"doc_values,omitempty"`
	// Dynamic controls whether new fields are added dynamically. Accepts true, false, "strict", or
	// "runtime".
	Dynamic any `json:"dynamic,omitempty" yaml:"dynamic,omitempty"`
	// The enabled setting, which can be applied only to the top-level mapping definition and to object
	// fields, causes Elasticsearch to skip parsing of the contents of the field entirely. The JSON can
	// still be retrieved from the _source field, but it is not searchable or stored in any other way.
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	// Example values for this field.
	Example any `json:"example,omitempty" yaml:"example,omitempty"`
	// An array of expected values for the field. When defined, these are the only expected values.
	ExpectedValues []string `json:"expected_values,omitempty" yaml:"expected_values,omitempty"`
	// External source reference
	External FieldExternal `json:"external,omitempty" yaml:"external,omitempty"`
	// Sub-fields, when type is group
	Fields []Field `json:"fields,omitempty" yaml:"fields,omitempty"`
	// Strings longer than the ignore_above setting will not be indexed or stored. For arrays of
	// strings, ignore_above will be applied for each array element separately and string elements
	// longer than ignore_above will not be indexed or stored. Fleet honors this for `keyword` and
	// `wildcard` types. Defaults to 1024.
	IgnoreAbove int `json:"ignore_above,omitempty" yaml:"ignore_above,omitempty"`
	// Trying to index the wrong data type into a field throws an exception by default, and rejects the
	// whole document. The ignore_malformed parameter, if set to true, allows the exception to be
	// ignored. The malformed field is not indexed, but other fields in the document are processed
	// normally. Defaults to false.
	IgnoreMalformed *bool `json:"ignore_malformed,omitempty" yaml:"ignore_malformed,omitempty"`
	// For nested field types, this specifies if all fields in the nested object are also added to the
	// parent document as standard (flat) fields.
	IncludeInParent *bool `json:"include_in_parent,omitempty" yaml:"include_in_parent,omitempty"`
	// For nested field types, this specifies if all fields in the nested object are also added to the
	// root document as standard (flat) fields.
	IncludeInRoot *bool `json:"include_in_root,omitempty" yaml:"include_in_root,omitempty"`
	// The index option controls whether field values are indexed. Fields that are not indexed are
	// typically not queryable.
	Index *bool `json:"index,omitempty" yaml:"index,omitempty"`
	// For semantic_text fields, this specifies the id of the inference endpoint associated with the
	// field
	InferenceID string `json:"inference_id,omitempty" yaml:"inference_id,omitempty"`
	// The metric type of a numeric field. This is attached to the field as a `time_series_metric`
	// mapping parameter. A gauge is a single-value measurement that can go up or down over time, such
	// as a temperature. A counter is a single-value cumulative counter that only goes up, such as the
	// number of requests processed by a web server. By default, no metric type is associated with a
	// field.
	MetricType FieldMetricType `json:"metric_type,omitempty" yaml:"metric_type,omitempty"`
	Metrics    any             `json:"metrics,omitempty" yaml:"metrics,omitempty"`
	// It is often useful to index the same field in different ways for different purposes. This is the
	// purpose of multi-fields. For instance, a string field could be mapped as a text field for
	// full-text search, and as a keyword field for sorting or aggregations. Fleet honors this for
	// `keyword`, `text`, and `wildcard` types.
	MultiFields []Field `json:"multi_fields,omitempty" yaml:"multi_fields,omitempty"`
	// Name of field. Names containing dots are automatically split into sub-fields. Names with
	// wildcards generate dynamic mappings.
	Name string `json:"name" yaml:"name"`
	// Specifies the expected normalizations for a field. `array` normalization implies that the values
	// in the field should always be an array, even if they are single values.
	Normalize []FieldNormalize `json:"normalize,omitempty" yaml:"normalize,omitempty"`
	// Specifies the name of a normalizer to apply to keyword fields. A simple normalizer called
	// lowercase ships with elasticsearch and can be used. Custom normalizers can be defined as part of
	// analysis index settings.
	Normalizer string `json:"normalizer,omitempty" yaml:"normalizer,omitempty"`
	// The null_value parameter allows you to replace explicit null values with the specified value so
	// that it can be indexed and searched. A null value cannot be indexed or searched. When a field is
	// set to null, (or an empty array or an array of null values) it is treated as though that field
	// has no values. The null_value needs to be the same data type as the field. For instance, a long
	// field cannot have a string null_value. The null_value only influences how data is indexed, it
	// doesn’t modify the _source document.
	NullValue any `json:"null_value,omitempty" yaml:"null_value,omitempty"`
	// Type of the members of the object when `type: object` is used. In these cases a dynamic template
	// is created so direct subobjects of this field have the type indicated. When
	// `object_type_mapping_type` is also used, the dynamic mapping is only applied to values that have
	// the given type, as detected by the JSON parser.
	ObjectType FieldObjectType `json:"object_type,omitempty" yaml:"object_type,omitempty"`
	// Type that members of a field of with `type: object` must have in the source document. This type
	// corresponds to the data type detected by the JSON parser, and is translated to the
	// `match_mapping_type` parameter of Elasticsearch dynamic templates.
	ObjectTypeMappingType FieldObjectTypeMappingType `json:"object_type_mapping_type,omitempty" yaml:"object_type_mapping_type,omitempty"`
	// For alias type fields this is the path to the target field. Note that this must be the full path,
	// including any parent objects (e.g. object1.object2.field).
	Path string `json:"path,omitempty" yaml:"path,omitempty"`
	// Regular expression pattern matching the allowed values for the field. This is used for
	// development-time data validation.
	Pattern string `json:"pattern,omitempty" yaml:"pattern,omitempty"`
	// Runtime specifies if this field is evaluated at query time. Can be a boolean or a script string.
	Runtime any `json:"runtime,omitempty" yaml:"runtime,omitempty"`
	// The scaling factor to use when encoding values. Values will be multiplied by this factor at index
	// time and rounded to the closest long value. For instance, a scaled_float with a scaling_factor of
	// 10 would internally store 2.34 as 23 and all search-time operations (queries, aggregations,
	// sorting) will behave as if the document had a value of 2.3. High values of scaling_factor improve
	// accuracy but also increase space requirements. Only valid for 'type: scaled_float'.
	ScalingFactor int `json:"scaling_factor,omitempty" yaml:"scaling_factor,omitempty"`
	// Name of the analyzer to use for searching. Only valid for 'type: text'.
	SearchAnalyzer string `json:"search_analyzer,omitempty" yaml:"search_analyzer,omitempty"`
	// By default, field values are indexed, but not stored. This means that the field can be queried,
	// but the original field cannot be retrieved. Setting this value to true ensures that the field is
	// also stored, what is useful in situations where the field would not be available even in the
	// _source, like when synthetic source mode is enabled.
	Store *bool `json:"store,omitempty" yaml:"store,omitempty"`
	// Specifies if field names containing dots should be expanded into subobjects. For example, if this
	// is set to `true`, a field named `foo.bar` will be expanded into an object with a field named
	// `bar` inside an object named `foo`.
	Subobjects *bool `json:"subobjects,omitempty" yaml:"subobjects,omitempty"`
	// Datatype of field. If the type is set to object, a dynamic mapping is created. In this case, if
	// the name doesn't contain any wildcard, the wildcard is added as the last segment of the path.
	Type FieldType `json:"type,omitempty" yaml:"type,omitempty"`
	// Unit type to associate with a numeric field. This is attached to the field as metadata (via
	// `meta`). By default, a field does not have a unit. The convention for percents is to use value 1
	// to mean 100%.
	Unit FieldUnit `json:"unit,omitempty" yaml:"unit,omitempty"`
	// The value to associate with a constant_keyword field.
	Value string `json:"value,omitempty" yaml:"value,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler for Field.
// It captures the YAML node position for FileMetadata.
func (v *Field) UnmarshalYAML(node *yamlv3.Node) error {
	type plainField Field
	x := (*plainField)(v)
	if err := node.Decode(x); err != nil {
		return err
	}
	v.FileMetadata.line = node.Line
	v.FileMetadata.column = node.Column
	return nil
}

// FieldExternal external source reference
type FieldExternal string

// Enum values for FieldExternal.
const (
	FieldExternalECS FieldExternal = "ecs"
)

// FieldMetricType the metric type of a numeric field. This is attached to the field as a
// `time_series_metric` mapping parameter. A gauge is a single-value measurement that can go up or
// down over time, such as a temperature. A counter is a single-value cumulative counter that only
// goes up, such as the number of requests processed by a web server. By default, no metric type is
// associated with a field.
type FieldMetricType string

// Enum values for FieldMetricType.
const (
	FieldMetricTypeCounter FieldMetricType = "counter"
	FieldMetricTypeGauge   FieldMetricType = "gauge"
)

type FieldNormalize string

// Enum values for FieldNormalize.
const (
	FieldNormalizeArray FieldNormalize = "array"
)

// FieldObjectType type of the members of the object when `type: object` is used. In these cases a
// dynamic template is created so direct subobjects of this field have the type indicated. When
// `object_type_mapping_type` is also used, the dynamic mapping is only applied to values that have
// the given type, as detected by the JSON parser.
type FieldObjectType string

// Enum values for FieldObjectType.
const (
	FieldObjectTypeBoolean      FieldObjectType = "boolean"
	FieldObjectTypeByte         FieldObjectType = "byte"
	FieldObjectTypeDouble       FieldObjectType = "double"
	FieldObjectTypeFloat        FieldObjectType = "float"
	FieldObjectTypeHistogram    FieldObjectType = "histogram"
	FieldObjectTypeKeyword      FieldObjectType = "keyword"
	FieldObjectTypeLong         FieldObjectType = "long"
	FieldObjectTypeObject       FieldObjectType = "object"
	FieldObjectTypeShort        FieldObjectType = "short"
	FieldObjectTypeText         FieldObjectType = "text"
	FieldObjectTypeInteger      FieldObjectType = "integer"
	FieldObjectTypeHalfFloat    FieldObjectType = "half_float"
	FieldObjectTypeScaledFloat  FieldObjectType = "scaled_float"
	FieldObjectTypeUnsignedLong FieldObjectType = "unsigned_long"
)

// FieldObjectTypeMappingType type that members of a field of with `type: object` must have in the
// source document. This type corresponds to the data type detected by the JSON parser, and is
// translated to the `match_mapping_type` parameter of Elasticsearch dynamic templates.
type FieldObjectTypeMappingType string

// Enum values for FieldObjectTypeMappingType.
const (
	FieldObjectTypeMappingTypeAny    FieldObjectTypeMappingType = "*"
	FieldObjectTypeMappingTypeArray  FieldObjectTypeMappingType = "array"
	FieldObjectTypeMappingTypeDouble FieldObjectTypeMappingType = "double"
	FieldObjectTypeMappingTypeFalse  FieldObjectTypeMappingType = "false"
	FieldObjectTypeMappingTypeLong   FieldObjectTypeMappingType = "long"
	FieldObjectTypeMappingTypeNull   FieldObjectTypeMappingType = "null"
	FieldObjectTypeMappingTypeObject FieldObjectTypeMappingType = "object"
	FieldObjectTypeMappingTypeString FieldObjectTypeMappingType = "string"
	FieldObjectTypeMappingTypeTrue   FieldObjectTypeMappingType = "true"
)

// FieldType represents the Elasticsearch mapping type of a field.
type FieldType string

// Enum values for FieldType.
const (
	FieldTypeAggregateMetricDouble FieldType = "aggregate_metric_double"
	FieldTypeAlias                 FieldType = "alias"
	FieldTypeHistogram             FieldType = "histogram"
	FieldTypeConstantKeyword       FieldType = "constant_keyword"
	FieldTypeText                  FieldType = "text"
	FieldTypeMatchOnlyText         FieldType = "match_only_text"
	FieldTypeKeyword               FieldType = "keyword"
	FieldTypeLong                  FieldType = "long"
	FieldTypeInteger               FieldType = "integer"
	FieldTypeShort                 FieldType = "short"
	FieldTypeByte                  FieldType = "byte"
	FieldTypeDouble                FieldType = "double"
	FieldTypeFloat                 FieldType = "float"
	FieldTypeHalfFloat             FieldType = "half_float"
	FieldTypeScaledFloat           FieldType = "scaled_float"
	FieldTypeDate                  FieldType = "date"
	FieldTypeDateNanos             FieldType = "date_nanos"
	FieldTypeBoolean               FieldType = "boolean"
	FieldTypeBinary                FieldType = "binary"
	FieldTypeIntegerRange          FieldType = "integer_range"
	FieldTypeFloatRange            FieldType = "float_range"
	FieldTypeLongRange             FieldType = "long_range"
	FieldTypeDoubleRange           FieldType = "double_range"
	FieldTypeDateRange             FieldType = "date_range"
	FieldTypeIPRange               FieldType = "ip_range"
	FieldTypeGroup                 FieldType = "group"
	FieldTypeGeoPoint              FieldType = "geo_point"
	FieldTypeObject                FieldType = "object"
	FieldTypeIP                    FieldType = "ip"
	FieldTypeNested                FieldType = "nested"
	FieldTypeFlattened             FieldType = "flattened"
	FieldTypeWildcard              FieldType = "wildcard"
	FieldTypeVersion               FieldType = "version"
	FieldTypeUnsignedLong          FieldType = "unsigned_long"
	FieldTypeCountedKeyword        FieldType = "counted_keyword"
	FieldTypeSemanticText          FieldType = "semantic_text"
)

// FieldUnit unit type to associate with a numeric field. This is attached to the field as metadata
// (via `meta`). By default, a field does not have a unit. The convention for percents is to use
// value 1 to mean 100%.
type FieldUnit string

// Enum values for FieldUnit.
const (
	FieldUnitByte    FieldUnit = "byte"
	FieldUnitPercent FieldUnit = "percent"
	FieldUnitD       FieldUnit = "d"
	FieldUnitH       FieldUnit = "h"
	FieldUnitM       FieldUnit = "m"
	FieldUnitS       FieldUnit = "s"
	FieldUnitMs      FieldUnit = "ms"
	FieldUnitMicros  FieldUnit = "micros"
	FieldUnitNanos   FieldUnit = "nanos"
)
