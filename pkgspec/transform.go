// Code generated by cmd/generate; DO NOT EDIT.

package pkgspec

import yamlv3 "gopkg.in/yaml.v3"

// Transform represents an Elasticsearch transform definition.
type Transform struct {
	FileMetadata `json:"-" yaml:"-"`
	// Meta holds user-defined metadata about the transform.
	Meta            map[string]any           `json:"_meta,omitempty" yaml:"_meta,omitempty"`
	Description     string                   `json:"description,omitempty" yaml:"description,omitempty"`
	Dest            TransformDest            `json:"dest" yaml:"dest"`
	Frequency       string                   `json:"frequency,omitempty" yaml:"frequency,omitempty"`
	ID              string                   `json:"id,omitempty" yaml:"id,omitempty"`
	Latest          TransformLatest          `json:"latest,omitempty" yaml:"latest,omitempty"`
	Pivot           TransformPivot           `json:"pivot,omitempty" yaml:"pivot,omitempty"`
	RetentionPolicy TransformRetentionPolicy `json:"retention_policy,omitempty" yaml:"retention_policy,omitempty"`
	Settings        TransformSettings        `json:"settings,omitempty" yaml:"settings,omitempty"`
	Source          TransformSource          `json:"source" yaml:"source"`
	Sync            TransformSync            `json:"sync,omitempty" yaml:"sync,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler for Transform.
// It captures the YAML node position for FileMetadata.
func (v *Transform) UnmarshalYAML(node *yamlv3.Node) error {
	type plainTransform Transform
	x := (*plainTransform)(v)
	if err := node.Decode(x); err != nil {
		return err
	}
	v.FileMetadata.line = node.Line
	v.FileMetadata.column = node.Column
	return nil
}

type TransformDest struct {
	// The aliases that the destination index for the transform should have.
	Aliases  []TransformDestAlias `json:"aliases,omitempty" yaml:"aliases,omitempty"`
	Index    string               `json:"index" yaml:"index"`
	Pipeline string               `json:"pipeline,omitempty" yaml:"pipeline,omitempty"`
}

type TransformDestAlias struct {
	// The name of the alias
	Alias string `json:"alias" yaml:"alias"`
	// Whether or not the destination index should be the only index in this alias. If true, all the
	// other indices will be removed from this alias before adding the destination index to this alias.
	MoveOnCreation *bool `json:"move_on_creation,omitempty" yaml:"move_on_creation,omitempty"`
}

// TransformDestIndexMode index mode for lookup indices.
type TransformDestIndexMode string

// Enum values for TransformDestIndexMode.
const (
	TransformDestIndexModeLookup TransformDestIndexMode = "lookup"
)

type TransformDestIndexSettings struct {
	Codec IndexCodec `json:"codec,omitempty" yaml:"codec,omitempty"`
	// Makes the index hidden.
	Hidden  *bool              `json:"hidden,omitempty" yaml:"hidden,omitempty"`
	Mapping IndexMappingConfig `json:"mapping,omitempty" yaml:"mapping,omitempty"`
	// Index mode for lookup indices.
	Mode TransformDestIndexMode `json:"mode,omitempty" yaml:"mode,omitempty"`
	// Number used when splitting shards.
	NumberOfRoutingShards int `json:"number_of_routing_shards,omitempty" yaml:"number_of_routing_shards,omitempty"`
	NumberOfShards        int `json:"number_of_shards,omitempty" yaml:"number_of_shards,omitempty"`
	// How often to perform a refresh operation, which makes recent changes to the index visible to
	// search.
	RefreshInterval string    `json:"refresh_interval,omitempty" yaml:"refresh_interval,omitempty"`
	Sort            IndexSort `json:"sort,omitempty" yaml:"sort,omitempty"`
}

// TransformDestIndexTemplate elasticsearch index template for the transform's destination index
type TransformDestIndexTemplate struct {
	DataStream     IndexTemplateDataStream            `json:"data_stream,omitempty" yaml:"data_stream,omitempty"`
	IngestPipeline IndexTemplatePipeline              `json:"ingest_pipeline,omitempty" yaml:"ingest_pipeline,omitempty"`
	Mappings       IndexTemplateMappings              `json:"mappings,omitempty" yaml:"mappings,omitempty"`
	Settings       TransformDestIndexTemplateSettings `json:"settings,omitempty" yaml:"settings,omitempty"`
}

type TransformDestIndexTemplateSettings struct {
	Analysis IndexAnalysis              `json:"analysis,omitempty" yaml:"analysis,omitempty"`
	Index    TransformDestIndexSettings `json:"index,omitempty" yaml:"index,omitempty"`
}

type TransformLatest struct {
	Sort      string `json:"sort" yaml:"sort"`
	UniqueKey []any  `json:"unique_key" yaml:"unique_key"`
}

type TransformManifest struct {
	FileMetadata `json:"-" yaml:"-"`
	// Elasticsearch index template for the transform's destination index
	DestinationIndexTemplate TransformDestIndexTemplate `json:"destination_index_template,omitempty" yaml:"destination_index_template,omitempty"`
	// Determines if the transform will be started upon installation
	Start *bool `json:"start,omitempty" yaml:"start,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler for TransformManifest.
// It captures the YAML node position for FileMetadata.
func (v *TransformManifest) UnmarshalYAML(node *yamlv3.Node) error {
	type plainTransformManifest TransformManifest
	x := (*plainTransformManifest)(v)
	if err := node.Decode(x); err != nil {
		return err
	}
	v.FileMetadata.line = node.Line
	v.FileMetadata.column = node.Column
	return nil
}

type TransformPivot struct {
	// Aggregations defines the aggregations for the pivot.
	Aggregations any `json:"aggregations,omitempty" yaml:"aggregations,omitempty"`
	// Aggs is an alias for Aggregations.
	Aggs any `json:"aggs,omitempty" yaml:"aggs,omitempty"`
	// GroupBy defines the grouping for the pivot.
	GroupBy any `json:"group_by" yaml:"group_by"`
}

type TransformRetentionPolicy struct {
	// Schema definition for a retention policy
	Time TransformRetentionPolicyTime `json:"time,omitempty" yaml:"time,omitempty"`
}

// TransformRetentionPolicyTime schema definition for a retention policy
type TransformRetentionPolicyTime struct {
	Field  string `json:"field" yaml:"field"`
	MaxAge string `json:"max_age" yaml:"max_age"`
}

type TransformSettings struct {
	AlignCheckpoints   *bool   `json:"align_checkpoints,omitempty" yaml:"align_checkpoints,omitempty"`
	DatesAsEpochMillis *bool   `json:"dates_as_epoch_millis,omitempty" yaml:"dates_as_epoch_millis,omitempty"`
	DeduceMappings     *bool   `json:"deduce_mappings,omitempty" yaml:"deduce_mappings,omitempty"`
	DocsPerSecond      float64 `json:"docs_per_second,omitempty" yaml:"docs_per_second,omitempty"`
	MaxPageSearchSize  int     `json:"max_page_search_size,omitempty" yaml:"max_page_search_size,omitempty"`
	Unattended         *bool   `json:"unattended,omitempty" yaml:"unattended,omitempty"`
	UsePointInTime     *bool   `json:"use_point_in_time,omitempty" yaml:"use_point_in_time,omitempty"`
}

type TransformSource struct {
	// Index is the source index or indices for the transform.
	Index any `json:"index" yaml:"index"`
	// Query filters the source documents.
	Query any `json:"query,omitempty" yaml:"query,omitempty"`
	// RuntimeMappings defines runtime fields for the source.
	RuntimeMappings any `json:"runtime_mappings,omitempty" yaml:"runtime_mappings,omitempty"`
}

type TransformSync struct {
	Time TransformSyncTime `json:"time,omitempty" yaml:"time,omitempty"`
}

type TransformSyncTime struct {
	Delay string `json:"delay,omitempty" yaml:"delay,omitempty"`
	Field string `json:"field" yaml:"field"`
}
