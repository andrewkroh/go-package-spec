package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	. "github.com/dave/jennifer/jen"
)

const (
	jsonPkg = "encoding/json"
)

const (
	yamlPkg = "gopkg.in/yaml.v3"
)

// Emitter generates Go source files from GoType definitions using jennifer/jen.
type Emitter struct {
	pkgName     string
	outputDir   string
	specVersion string
}

// NewEmitter creates an Emitter targeting the given package name and directory.
func NewEmitter(pkgName, outputDir, specVersion string) *Emitter {
	return &Emitter{
		pkgName:     pkgName,
		outputDir:   outputDir,
		specVersion: specVersion,
	}
}

// Emit generates all Go source files for the given types.
func (e *Emitter) Emit(types []*GoType) error {
	if err := os.MkdirAll(e.outputDir, 0o755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Group types by output file, skipping excluded types.
	fileTypes := make(map[string][]*GoType)
	for _, t := range types {
		file := t.OutputFile
		if file == ExcludeFile {
			continue
		}
		if file == "" {
			file = "types.go"
		}
		fileTypes[file] = append(fileTypes[file], t)
	}

	// Sort types within each file by name.
	for _, tt := range fileTypes {
		sort.Slice(tt, func(i, j int) bool {
			return tt[i].Name < tt[j].Name
		})
	}

	// Emit each file.
	for filename, tt := range fileTypes {
		if err := e.emitFile(filename, tt); err != nil {
			return fmt.Errorf("emitting %s: %w", filename, err)
		}
	}

	// Always emit metadata.go.
	if err := e.emitMetadata(); err != nil {
		return fmt.Errorf("emitting metadata.go: %w", err)
	}

	// Always emit version.go.
	if err := e.emitVersion(); err != nil {
		return fmt.Errorf("emitting version.go: %w", err)
	}

	return nil
}

// emitFile generates a single Go source file containing the given types.
func (e *Emitter) emitFile(filename string, types []*GoType) error {
	f := NewFile(e.pkgName)
	f.HeaderComment("Code generated by cmd/generate; DO NOT EDIT.")

	for _, goType := range types {
		switch goType.Kind {
		case GoTypeStruct:
			e.emitStruct(f, goType)
		case GoTypeEnum:
			e.emitEnum(f, goType)
		}
	}

	path := filepath.Join(e.outputDir, filename)
	return f.Save(path)
}

// emitStruct generates a struct type declaration with fields and UnmarshalYAML.
func (e *Emitter) emitStruct(f *File, goType *GoType) {
	// Type doc comment.
	if goType.Doc != "" {
		for _, line := range wrapComment(formatDocComment(goType.Name, goType.Doc), 100) {
			f.Comment(line)
		}
	}

	// Struct definition.
	fields := make([]Code, 0, len(goType.Fields)+1)

	// Embed FileMetadata if needed.
	if goType.EmbedMeta {
		fields = append(fields, Id("FileMetadata").Tag(map[string]string{
			"json": "-",
			"yaml": "-",
		}))
	}

	for _, field := range goType.Fields {
		if field.Doc != "" {
			for _, line := range wrapComment(formatFieldDocComment(field.Doc), 100) {
				fields = append(fields, Comment(line))
			}
		}
		fieldCode := e.fieldDecl(field)
		fields = append(fields, fieldCode)
	}

	f.Type().Id(goType.Name).Struct(fields...)
	f.Line()

	// Generate UnmarshalYAML for types that need YAML position capture.
	if goType.EmbedMeta || goType.NeedsUnmarshalYAML {
		e.emitUnmarshalYAML(f, goType)
	}

	// Generate MarshalJSON for types with additional properties.
	if goType.HasAdditionalProperties {
		e.emitMarshalJSON(f, goType)
	}
}

// fieldDecl generates a struct field declaration with tags.
func (e *Emitter) fieldDecl(field GoField) Code {
	// Embed fields: no tags unless custom tags are provided.
	if field.Embed {
		if field.JSONTag != "" || field.YAMLTag != "" {
			tags := map[string]string{}
			if field.JSONTag != "" {
				tags["json"] = field.JSONTag
			}
			if field.YAMLTag != "" {
				tags["yaml"] = field.YAMLTag
			}
			return Id(field.Name).Tag(tags)
		}
		return Id(field.Name)
	}

	// Build tags. Required fields omit ",omitempty" to signal that
	// the field is expected to always be present.
	jsonTag := field.JSONName
	yamlTag := field.JSONName
	if !field.Required {
		jsonTag += ",omitempty"
		yamlTag += ",omitempty"
	}
	if field.JSONName == "-" {
		jsonTag = "-"
		yamlTag = "-"
	}

	// Allow custom tag overrides from extra fields.
	if field.JSONTag != "" {
		jsonTag = field.JSONTag
	}
	if field.YAMLTag != "" {
		yamlTag = field.YAMLTag
	}

	return Id(field.Name).Add(e.typeExpr(&field.Type)).Tag(map[string]string{
		"json": jsonTag,
		"yaml": yamlTag,
	})
}

// typeExpr generates a type expression for use in composite types.
func (e *Emitter) typeExpr(ref *GoTypeRef) *Statement {
	if ref == nil {
		return Interface()
	}
	if ref.Pointer {
		inner := *ref
		inner.Pointer = false
		return Op("*").Add(e.typeExpr(&inner))
	}
	if ref.Slice {
		if ref.Element != nil {
			return Index().Add(e.typeExpr(ref.Element))
		}
		return Index().Interface()
	}
	if ref.Map {
		key := e.typeExpr(ref.MapKey)
		val := e.typeExpr(ref.MapValue)
		return Map(key).Add(val)
	}
	if ref.Builtin != "" {
		switch ref.Builtin {
		case "any":
			return Any()
		case "string":
			return String()
		case "int":
			return Int()
		case "int64":
			return Int64()
		case "float64":
			return Float64()
		case "bool":
			return Bool()
		default:
			return Id(ref.Builtin)
		}
	}
	if ref.QualName != "" {
		return Qual(ref.Package, ref.QualName)
	}
	if ref.Named != "" {
		return Id(ref.Named)
	}
	return Any()
}

// emitUnmarshalYAML generates the UnmarshalYAML method using the type-alias trick.
func (e *Emitter) emitUnmarshalYAML(f *File, goType *GoType) {
	aliasName := "plain" + goType.Name

	// Build the method body.
	var body []Code

	// type alias = TypeName
	body = append(body, Type().Id(aliasName).Id(goType.Name))
	// x := (*alias)(v)
	body = append(body, Id("x").Op(":=").Parens(Op("*").Id(aliasName)).Parens(Id("v")))
	// if err := node.Decode(x); err != nil { return err }
	body = append(body, If(
		Err().Op(":=").Id("node").Dot("Decode").Call(Id("x")),
		Err().Op("!=").Nil(),
	).Block(
		Return(Err()),
	))

	// For types with embedded base structs (NeedsUnmarshalYAML), the
	// type-alias trick doesn't populate promoted fields from Go embeds.
	// Decode each embedded struct separately to work around this.
	for _, field := range goType.Fields {
		if field.Embed && field.Type.Named != "" && field.Name != "FileMetadata" {
			body = append(body, If(
				Err().Op(":=").Id("node").Dot("Decode").Call(Op("&").Id("v").Dot(field.Name)),
				Err().Op("!=").Nil(),
			).Block(
				Return(Err()),
			))
		}
	}

	// v.FileMetadata.line = node.Line
	body = append(body, Id("v").Dot("FileMetadata").Dot("line").Op("=").Id("node").Dot("Line"))
	// v.FileMetadata.column = node.Column
	body = append(body, Id("v").Dot("FileMetadata").Dot("column").Op("=").Id("node").Dot("Column"))
	body = append(body, Return(Nil()))

	f.Comment(fmt.Sprintf("UnmarshalYAML implements yaml.Unmarshaler for %s.", goType.Name))
	f.Comment("It captures the YAML node position for FileMetadata.")
	f.Func().Params(
		Id("v").Op("*").Id(goType.Name),
	).Id("UnmarshalYAML").Params(
		Id("node").Op("*").Qual(yamlPkg, "Node"),
	).Error().Block(body...)
	f.Line()
}

// emitMarshalJSON generates a MarshalJSON method that merges additional
// properties into the flat JSON output. It uses the type-alias trick to
// marshal declared fields, then overlays the AdditionalProperties map.
func (e *Emitter) emitMarshalJSON(f *File, goType *GoType) {
	aliasName := "plain" + goType.Name

	var body []Code

	// type alias = TypeName
	body = append(body, Type().Id(aliasName).Id(goType.Name))

	// data, err := json.Marshal(alias(v))
	body = append(body,
		List(Id("data"), Err()).Op(":=").Qual(jsonPkg, "Marshal").Call(
			Id(aliasName).Call(Id("v")),
		),
	)
	// if err != nil { return nil, err }
	body = append(body, If(Err().Op("!=").Nil()).Block(
		Return(Nil(), Err()),
	))

	// if len(v.AdditionalProperties) == 0 { return data, nil }
	body = append(body, If(
		Len(Id("v").Dot("AdditionalProperties")).Op("==").Lit(0),
	).Block(
		Return(Id("data"), Nil()),
	))

	// var m map[string]any
	body = append(body, Var().Id("m").Map(String()).Any())

	// if err := json.Unmarshal(data, &m); err != nil { return nil, err }
	body = append(body, If(
		Err().Op(":=").Qual(jsonPkg, "Unmarshal").Call(Id("data"), Op("&").Id("m")),
		Err().Op("!=").Nil(),
	).Block(
		Return(Nil(), Err()),
	))

	// for k, val := range v.AdditionalProperties { if _, exists := m[k]; !exists { m[k] = val } }
	body = append(body, For(
		List(Id("k"), Id("val")).Op(":=").Range().Id("v").Dot("AdditionalProperties"),
	).Block(
		If(
			List(Id("_"), Id("exists")).Op(":=").Id("m").Index(Id("k")),
			Op("!").Id("exists"),
		).Block(
			Id("m").Index(Id("k")).Op("=").Id("val"),
		),
	))

	// return json.Marshal(m)
	body = append(body, Return(Qual(jsonPkg, "Marshal").Call(Id("m"))))

	f.Comment(fmt.Sprintf("MarshalJSON implements json.Marshaler for %s.", goType.Name))
	f.Comment("It merges AdditionalProperties into the flat JSON output.")
	f.Func().Params(
		Id("v").Id(goType.Name),
	).Id("MarshalJSON").Params().Parens(List(Index().Byte(), Error())).Block(body...)
	f.Line()
}

// emitEnum generates a string type and const block for enum values.
func (e *Emitter) emitEnum(f *File, goType *GoType) {
	if goType.Doc != "" {
		for _, line := range wrapComment(formatDocComment(goType.Name, goType.Doc), 100) {
			f.Comment(line)
		}
	}
	f.Type().Id(goType.Name).String()
	f.Line()

	if len(goType.EnumValues) > 0 {
		f.Comment(fmt.Sprintf("Enum values for %s.", goType.Name))
		consts := make([]Code, len(goType.EnumValues))
		for i, ev := range goType.EnumValues {
			consts[i] = Id(ev.GoName).Id(goType.Name).Op("=").Lit(ev.Value)
		}
		f.Const().Defs(consts...)
		f.Line()
	}
}

// emitMetadata generates the metadata.go file with FileMetadata and
// annotateFileMetadata.
func (e *Emitter) emitMetadata() error {
	f := NewFile(e.pkgName)
	f.HeaderComment("Code generated by cmd/generate; DO NOT EDIT.")

	// Import reflect.
	f.ImportName("reflect", "reflect")

	// FileMetadata struct.
	f.Comment("FileMetadata records the source file location from which a value was loaded.")
	f.Type().Id("FileMetadata").Struct(
		Id("file").String().Comment("file from which value was read."),
		Id("line").Int().Comment("line from which value was read."),
		Id("column").Int().Comment("column from which value was read."),
	)
	f.Line()

	// Accessor methods.
	f.Comment("FilePath returns the file path from which the value was loaded.")
	f.Func().Params(Id("m").Id("FileMetadata")).Id("FilePath").Params().String().Block(
		Return(Id("m").Dot("file")),
	)
	f.Line()

	f.Comment("Line returns the line number in the source file.")
	f.Func().Params(Id("m").Id("FileMetadata")).Id("Line").Params().Int().Block(
		Return(Id("m").Dot("line")),
	)
	f.Line()

	f.Comment("Column returns the column number in the source file.")
	f.Func().Params(Id("m").Id("FileMetadata")).Id("Column").Params().Int().Block(
		Return(Id("m").Dot("column")),
	)
	f.Line()

	// annotateFileMetadata function.
	f.Comment("annotateFileMetadata sets the file name on any types that contain FileMetadata.")
	f.Func().Id("annotateFileMetadata").Params(
		Id("file").String(),
		Id("v").Any(),
	).Block(
		Id("fileAnnotator").Values(Dict{
			Id("name"): Id("file"),
		}).Dot("annotate").Call(Qual("reflect", "ValueOf").Call(Id("v"))),
	)
	f.Line()

	// fileAnnotator struct.
	f.Type().Id("fileAnnotator").Struct(
		Id("name").String(),
	)
	f.Line()

	// annotate method.
	f.Func().Params(Id("a").Id("fileAnnotator")).Id("annotate").Params(
		Id("val").Qual("reflect", "Value"),
	).Block(
		If(
			Id("val").Dot("CanAddr").Call().Op("&&").Id("val").Dot("CanSet").Call(),
		).Block(
			If(
				List(Id("m"), Id("ok")).Op(":=").Id("val").Dot("Addr").Call().Dot("Interface").Call().Assert(Op("*").Id("FileMetadata")),
				Id("ok"),
			).Block(
				Id("m").Dot("file").Op("=").Id("a").Dot("name"),
				Return(),
			),
		),
		Line(),
		Switch(Id("val").Dot("Kind").Call()).Block(
			Case(Qual("reflect", "Pointer")).Block(
				If(Op("!").Id("val").Dot("IsNil").Call()).Block(
					Id("a").Dot("annotate").Call(Id("val").Dot("Elem").Call()),
				),
			),
			Case(Qual("reflect", "Struct")).Block(
				For(
					Id("i").Op(":=").Lit(0),
					Id("i").Op("<").Id("val").Dot("NumField").Call(),
					Id("i").Op("++"),
				).Block(
					Id("a").Dot("annotate").Call(Id("val").Dot("Field").Call(Id("i"))),
				),
			),
			Case(Qual("reflect", "Slice")).Block(
				For(
					Id("i").Op(":=").Lit(0),
					Id("i").Op("<").Id("val").Dot("Len").Call(),
					Id("i").Op("++"),
				).Block(
					Id("a").Dot("annotate").Call(Id("val").Dot("Index").Call(Id("i"))),
				),
			),
			Case(Qual("reflect", "Map")).Block(
				Id("itr").Op(":=").Id("val").Dot("MapRange").Call(),
				For(Id("itr").Dot("Next").Call()).Block(
					Id("a").Dot("annotate").Call(Id("itr").Dot("Value").Call()),
				),
			),
		),
	)
	f.Line()

	path := filepath.Join(e.outputDir, "metadata.go")
	return f.Save(path)
}

// emitVersion generates the version.go file with a SpecVersion constant.
func (e *Emitter) emitVersion() error {
	f := NewFile(e.pkgName)
	f.HeaderComment("Code generated by cmd/generate; DO NOT EDIT.")

	f.Comment("SpecVersion is the package-spec schema version used to generate this package.")
	f.Const().Id("SpecVersion").Op("=").Lit(e.specVersion)
	f.Line()

	path := filepath.Join(e.outputDir, "version.go")
	return f.Save(path)
}

var mdLinkRe = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)

// docComment holds formatted doc text and any extracted link definitions.
type docComment struct {
	paragraphs []string         // paragraphs separated by blank lines in the output
	links      []docCommentLink // extracted link definitions in order of appearance
}

type docCommentLink struct {
	text string
	url  string
}

// extractLinks replaces Markdown links [text](url) with Go doc [text]
// references, collecting link definitions for appending at the end.
func extractLinks(doc string) (string, []docCommentLink) {
	var links []docCommentLink
	seen := map[string]bool{}
	doc = mdLinkRe.ReplaceAllStringFunc(doc, func(match string) string {
		m := mdLinkRe.FindStringSubmatch(match)
		linkText, linkURL := m[1], m[2]
		if !seen[linkText] {
			seen[linkText] = true
			links = append(links, docCommentLink{text: linkText, url: linkURL})
		}
		return "[" + linkText + "]"
	})
	return doc, links
}

// splitParagraphs splits a doc string into paragraphs at newline boundaries.
// Each non-empty line (or group of continuation lines) becomes a separate
// paragraph. Within each paragraph, whitespace is normalized to single spaces.
func splitParagraphs(doc string) []string {
	doc = strings.TrimSpace(doc)
	if doc == "" {
		return nil
	}

	// If no newlines, treat as a single paragraph.
	if !strings.Contains(doc, "\n") {
		return []string{strings.Join(strings.Fields(doc), " ")}
	}

	// Each newline-separated line becomes a paragraph. Continuation lines
	// (indented with leading whitespace) are joined to the previous line.
	// Blank lines are skipped (they don't produce empty paragraphs).
	rawLines := strings.Split(doc, "\n")
	var paragraphs []string
	var current strings.Builder

	flush := func() {
		text := strings.Join(strings.Fields(current.String()), " ")
		if text != "" {
			paragraphs = append(paragraphs, text)
		}
		current.Reset()
	}

	for _, line := range rawLines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" {
			flush()
			continue
		}
		// A line that starts with a lowercase letter, or is indented,
		// is a continuation of the previous paragraph.
		isContinuation := current.Len() > 0 &&
			(len(line) > 0 && (line[0] == ' ' || line[0] == '\t') ||
				len(trimmed) > 0 && trimmed[0] >= 'a' && trimmed[0] <= 'z')
		if isContinuation {
			current.WriteByte(' ')
			current.WriteString(trimmed)
			continue
		}
		// Otherwise, start a new paragraph.
		flush()
		current.WriteString(trimmed)
	}
	flush()

	return paragraphs
}

// formatDocComment formats a Go doc comment for a type or enum.
// It ensures the comment starts with the type name per Go convention,
// converts Markdown links to Go doc link references, and preserves
// paragraph structure from the original description.
func formatDocComment(name, doc string) docComment {
	doc = strings.TrimSpace(doc)
	if doc == "" {
		return docComment{paragraphs: []string{name + " is a generated type."}}
	}

	// Extract links before splitting paragraphs.
	doc, links := extractLinks(doc)

	paragraphs := splitParagraphs(doc)
	if len(paragraphs) == 0 {
		return docComment{paragraphs: []string{name + " is a generated type."}, links: links}
	}

	// Prepend name to the first paragraph per Go convention.
	first := paragraphs[0]
	if !strings.HasPrefix(first, name+" ") && !strings.HasPrefix(first, name+".") {
		firstChar := strings.ToLower(first[:1])
		if first[:1] == strings.ToUpper(first[:1]) {
			if len(first) > 1 && first[1:2] == strings.ToUpper(first[1:2]) {
				firstChar = first[:1]
			}
		}
		paragraphs[0] = name + " " + firstChar + first[1:]
	}

	return docComment{paragraphs: paragraphs, links: links}
}

// formatFieldDocComment formats a doc comment for a struct field.
// Unlike type-level comments, field comments do not prepend the field name,
// since the field name is already visible in the struct declaration.
func formatFieldDocComment(doc string) docComment {
	doc = strings.TrimSpace(doc)
	if doc == "" {
		return docComment{}
	}

	doc, links := extractLinks(doc)

	paragraphs := splitParagraphs(doc)
	if len(paragraphs) == 0 {
		return docComment{}
	}

	// Capitalize the first letter of the first paragraph.
	first := paragraphs[0]
	if len(first) > 0 {
		paragraphs[0] = strings.ToUpper(first[:1]) + first[1:]
	}

	return docComment{paragraphs: paragraphs, links: links}
}

// wrapComment word-wraps a docComment into lines that fit within maxWidth
// characters including the "// " prefix (3 chars). Paragraphs are separated
// by blank comment lines. Link definitions are appended after a blank line.
func wrapComment(dc docComment, maxWidth int) []string {
	contentWidth := maxWidth - 3 // account for "// " prefix
	if contentWidth < 20 {
		contentWidth = 20
	}

	var lines []string
	for i, para := range dc.paragraphs {
		if i > 0 {
			lines = append(lines, "") // blank line between paragraphs
		}
		lines = append(lines, wrapText(para, contentWidth)...)
	}

	// Append link definitions.
	if len(dc.links) > 0 {
		lines = append(lines, "")
		for _, link := range dc.links {
			lines = append(lines, "["+link.text+"]: "+link.url)
		}
	}

	return lines
}

// wrapText word-wraps a single paragraph into lines of at most maxWidth chars.
func wrapText(text string, maxWidth int) []string {
	var lines []string
	for len(text) > 0 {
		if len(text) <= maxWidth {
			lines = append(lines, text)
			break
		}

		cut := maxWidth
		for cut > 0 && text[cut] != ' ' {
			cut--
		}
		if cut == 0 {
			// The current word exceeds maxWidth (e.g. a long URL).
			// Keep it intact by finding the next space instead.
			cut = strings.IndexByte(text, ' ')
			if cut == -1 {
				lines = append(lines, text)
				break
			}
		}

		lines = append(lines, text[:cut])
		text = strings.TrimLeft(text[cut:], " ")
	}
	return lines
}
