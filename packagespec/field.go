// Code generated by cmd/generate; DO NOT EDIT.

package packagespec

import yamlv3 "gopkg.in/yaml.v3"

// Field represents a field definition in a data stream's field mapping.
type Field struct {
	FileMetadata          `json:"-" yaml:"-"`
	Analyzer              string                     `json:"analyzer,omitempty" yaml:"analyzer,omitempty"`
	CopyTo                string                     `json:"copy_to,omitempty" yaml:"copy_to,omitempty"`
	DateFormat            string                     `json:"date_format,omitempty" yaml:"date_format,omitempty"`
	DefaultMetric         any                        `json:"default_metric,omitempty" yaml:"default_metric,omitempty"`
	Description           string                     `json:"description,omitempty" yaml:"description,omitempty"`
	Dimension             *bool                      `json:"dimension,omitempty" yaml:"dimension,omitempty"`
	DocValues             *bool                      `json:"doc_values,omitempty" yaml:"doc_values,omitempty"`
	Dynamic               any                        `json:"dynamic,omitempty" yaml:"dynamic,omitempty"`
	Enabled               *bool                      `json:"enabled,omitempty" yaml:"enabled,omitempty"`
	Example               any                        `json:"example,omitempty" yaml:"example,omitempty"`
	ExpectedValues        []string                   `json:"expected_values,omitempty" yaml:"expected_values,omitempty"`
	External              FieldExternal              `json:"external,omitempty" yaml:"external,omitempty"`
	Fields                []Field                    `json:"fields,omitempty" yaml:"fields,omitempty"`
	IgnoreAbove           int                        `json:"ignore_above,omitempty" yaml:"ignore_above,omitempty"`
	IgnoreMalformed       *bool                      `json:"ignore_malformed,omitempty" yaml:"ignore_malformed,omitempty"`
	IncludeInParent       *bool                      `json:"include_in_parent,omitempty" yaml:"include_in_parent,omitempty"`
	IncludeInRoot         *bool                      `json:"include_in_root,omitempty" yaml:"include_in_root,omitempty"`
	Index                 *bool                      `json:"index,omitempty" yaml:"index,omitempty"`
	InferenceID           string                     `json:"inference_id,omitempty" yaml:"inference_id,omitempty"`
	MetricType            FieldMetricType            `json:"metric_type,omitempty" yaml:"metric_type,omitempty"`
	Metrics               any                        `json:"metrics,omitempty" yaml:"metrics,omitempty"`
	MultiFields           []Field                    `json:"multi_fields,omitempty" yaml:"multi_fields,omitempty"`
	Name                  string                     `json:"name,omitempty" yaml:"name,omitempty"`
	Normalize             []FieldNormalize           `json:"normalize,omitempty" yaml:"normalize,omitempty"`
	Normalizer            string                     `json:"normalizer,omitempty" yaml:"normalizer,omitempty"`
	NullValue             any                        `json:"null_value,omitempty" yaml:"null_value,omitempty"`
	ObjectType            FieldObjectType            `json:"object_type,omitempty" yaml:"object_type,omitempty"`
	ObjectTypeMappingType FieldObjectTypeMappingType `json:"object_type_mapping_type,omitempty" yaml:"object_type_mapping_type,omitempty"`
	Path                  string                     `json:"path,omitempty" yaml:"path,omitempty"`
	Pattern               string                     `json:"pattern,omitempty" yaml:"pattern,omitempty"`
	Runtime               any                        `json:"runtime,omitempty" yaml:"runtime,omitempty"`
	ScalingFactor         int                        `json:"scaling_factor,omitempty" yaml:"scaling_factor,omitempty"`
	SearchAnalyzer        string                     `json:"search_analyzer,omitempty" yaml:"search_analyzer,omitempty"`
	Store                 *bool                      `json:"store,omitempty" yaml:"store,omitempty"`
	Subobjects            *bool                      `json:"subobjects,omitempty" yaml:"subobjects,omitempty"`
	Type                  FieldType                  `json:"type,omitempty" yaml:"type,omitempty"`
	Unit                  FieldUnit                  `json:"unit,omitempty" yaml:"unit,omitempty"`
	Value                 string                     `json:"value,omitempty" yaml:"value,omitempty"`
}

// UnmarshalYAML implements yaml.Unmarshaler for Field.
// It captures the YAML node position for FileMetadata.
func (v *Field) UnmarshalYAML(node *yamlv3.Node) error {
	type plainField Field
	x := (*plainField)(v)
	if err := node.Decode(x); err != nil {
		return err
	}
	v.FileMetadata.line = node.Line
	v.FileMetadata.column = node.Column
	return nil
}

// FieldExternal external source reference
type FieldExternal string

// Enum values for FieldExternal.
const (
	FieldExternalECS FieldExternal = "ecs"
)

// FieldMetricType the metric type of a numeric field. This is attached to the field as a `time_series_metric` mapping parameter. A gauge is a single-value measurement that can go up or down over time, such as a temperature. A counter is a single-value cumulative counter that only goes up, such as the number of requests processed by a web server. By default, no metric type is associated with a field.
type FieldMetricType string

// Enum values for FieldMetricType.
const (
	FieldMetricTypeCounter FieldMetricType = "counter"
	FieldMetricTypeGauge   FieldMetricType = "gauge"
)

type FieldNormalize string

// Enum values for FieldNormalize.
const (
	FieldNormalizeArray FieldNormalize = "array"
)

// FieldObjectType type of the members of the object when `type: object` is used. In these cases a dynamic template is created so direct subobjects of this field have the type indicated. When `object_type_mapping_type` is also used, the dynamic mapping is only applied to values that have the given type, as detected by the JSON parser.
type FieldObjectType string

// Enum values for FieldObjectType.
const (
	FieldObjectTypeBoolean      FieldObjectType = "boolean"
	FieldObjectTypeByte         FieldObjectType = "byte"
	FieldObjectTypeDouble       FieldObjectType = "double"
	FieldObjectTypeFloat        FieldObjectType = "float"
	FieldObjectTypeHistogram    FieldObjectType = "histogram"
	FieldObjectTypeKeyword      FieldObjectType = "keyword"
	FieldObjectTypeLong         FieldObjectType = "long"
	FieldObjectTypeObject       FieldObjectType = "object"
	FieldObjectTypeShort        FieldObjectType = "short"
	FieldObjectTypeText         FieldObjectType = "text"
	FieldObjectTypeInteger      FieldObjectType = "integer"
	FieldObjectTypeHalfFloat    FieldObjectType = "half_float"
	FieldObjectTypeScaledFloat  FieldObjectType = "scaled_float"
	FieldObjectTypeUnsignedLong FieldObjectType = "unsigned_long"
)

// FieldObjectTypeMappingType type that members of a field of with `type: object` must have in the source document. This type corresponds to the data type detected by the JSON parser, and is translated to the `match_mapping_type` parameter of Elasticsearch dynamic templates.
type FieldObjectTypeMappingType string

// Enum values for FieldObjectTypeMappingType.
const (
	FieldObjectTypeMappingTypeAny    FieldObjectTypeMappingType = "*"
	FieldObjectTypeMappingTypeArray  FieldObjectTypeMappingType = "array"
	FieldObjectTypeMappingTypeDouble FieldObjectTypeMappingType = "double"
	FieldObjectTypeMappingTypeFalse  FieldObjectTypeMappingType = "false"
	FieldObjectTypeMappingTypeLong   FieldObjectTypeMappingType = "long"
	FieldObjectTypeMappingTypeNull   FieldObjectTypeMappingType = "null"
	FieldObjectTypeMappingTypeObject FieldObjectTypeMappingType = "object"
	FieldObjectTypeMappingTypeString FieldObjectTypeMappingType = "string"
	FieldObjectTypeMappingTypeTrue   FieldObjectTypeMappingType = "true"
)

// FieldUnit unit type to associate with a numeric field. This is attached to the field as metadata (via `meta`). By default, a field does not have a unit. The convention for percents is to use value 1 to mean 100%.
type FieldUnit string

// Enum values for FieldUnit.
const (
	FieldUnitByte    FieldUnit = "byte"
	FieldUnitPercent FieldUnit = "percent"
	FieldUnitD       FieldUnit = "d"
	FieldUnitH       FieldUnit = "h"
	FieldUnitM       FieldUnit = "m"
	FieldUnitS       FieldUnit = "s"
	FieldUnitMs      FieldUnit = "ms"
	FieldUnitMicros  FieldUnit = "micros"
	FieldUnitNanos   FieldUnit = "nanos"
)
