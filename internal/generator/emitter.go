package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	. "github.com/dave/jennifer/jen"
)

const (
	yamlPkg = "gopkg.in/yaml.v3"
)

// Emitter generates Go source files from GoType definitions using jennifer/jen.
type Emitter struct {
	pkgName   string
	outputDir string
}

// NewEmitter creates an Emitter targeting the given package name and directory.
func NewEmitter(pkgName, outputDir string) *Emitter {
	return &Emitter{
		pkgName:   pkgName,
		outputDir: outputDir,
	}
}

// Emit generates all Go source files for the given types.
func (e *Emitter) Emit(types []*GoType) error {
	if err := os.MkdirAll(e.outputDir, 0o755); err != nil {
		return fmt.Errorf("creating output directory: %w", err)
	}

	// Group types by output file.
	fileTypes := make(map[string][]*GoType)
	for _, t := range types {
		file := t.OutputFile
		if file == "" {
			file = "types.go"
		}
		fileTypes[file] = append(fileTypes[file], t)
	}

	// Sort types within each file by name.
	for _, tt := range fileTypes {
		sort.Slice(tt, func(i, j int) bool {
			return tt[i].Name < tt[j].Name
		})
	}

	// Emit each file.
	for filename, tt := range fileTypes {
		if err := e.emitFile(filename, tt); err != nil {
			return fmt.Errorf("emitting %s: %w", filename, err)
		}
	}

	// Always emit metadata.go.
	if err := e.emitMetadata(); err != nil {
		return fmt.Errorf("emitting metadata.go: %w", err)
	}

	return nil
}

// emitFile generates a single Go source file containing the given types.
func (e *Emitter) emitFile(filename string, types []*GoType) error {
	f := NewFile(e.pkgName)
	f.HeaderComment("Code generated by cmd/generate; DO NOT EDIT.")

	for _, goType := range types {
		switch goType.Kind {
		case GoTypeStruct:
			e.emitStruct(f, goType)
		case GoTypeEnum:
			e.emitEnum(f, goType)
		}
	}

	path := filepath.Join(e.outputDir, filename)
	return f.Save(path)
}

// emitStruct generates a struct type declaration with fields and UnmarshalYAML.
func (e *Emitter) emitStruct(f *File, goType *GoType) {
	// Type doc comment.
	if goType.Doc != "" {
		f.Comment(formatDocComment(goType.Name, goType.Doc))
	}

	// Struct definition.
	fields := make([]Code, 0, len(goType.Fields)+1)

	// Embed FileMetadata if needed.
	if goType.EmbedMeta {
		fields = append(fields, Id("FileMetadata").Tag(map[string]string{
			"json": "-",
			"yaml": "-",
		}))
	}

	for _, field := range goType.Fields {
		fieldCode := e.fieldDecl(field)
		fields = append(fields, fieldCode)
	}

	f.Type().Id(goType.Name).Struct(fields...)
	f.Line()

	// Generate UnmarshalYAML for types that need YAML position capture.
	if goType.EmbedMeta || goType.NeedsUnmarshalYAML {
		e.emitUnmarshalYAML(f, goType)
	}
}

// fieldDecl generates a struct field declaration with tags.
func (e *Emitter) fieldDecl(field GoField) Code {
	// Embed fields: no tags unless custom tags are provided.
	if field.Embed {
		if field.JSONTag != "" || field.YAMLTag != "" {
			tags := map[string]string{}
			if field.JSONTag != "" {
				tags["json"] = field.JSONTag
			}
			if field.YAMLTag != "" {
				tags["yaml"] = field.YAMLTag
			}
			return Id(field.Name).Tag(tags)
		}
		return Id(field.Name)
	}

	// Build tags.
	jsonTag := field.JSONName + ",omitempty"
	yamlTag := field.JSONName + ",omitempty"
	if field.JSONName == "-" {
		jsonTag = "-"
		yamlTag = "-"
	}

	// Allow custom tag overrides from extra fields.
	if field.JSONTag != "" {
		jsonTag = field.JSONTag
	}
	if field.YAMLTag != "" {
		yamlTag = field.YAMLTag
	}

	return Id(field.Name).Add(e.typeExpr(&field.Type)).Tag(map[string]string{
		"json": jsonTag,
		"yaml": yamlTag,
	})
}

// typeExpr generates a type expression for use in composite types.
func (e *Emitter) typeExpr(ref *GoTypeRef) *Statement {
	if ref == nil {
		return Interface()
	}
	if ref.Pointer {
		inner := *ref
		inner.Pointer = false
		return Op("*").Add(e.typeExpr(&inner))
	}
	if ref.Slice {
		if ref.Element != nil {
			return Index().Add(e.typeExpr(ref.Element))
		}
		return Index().Interface()
	}
	if ref.Map {
		key := e.typeExpr(ref.MapKey)
		val := e.typeExpr(ref.MapValue)
		return Map(key).Add(val)
	}
	if ref.Builtin != "" {
		switch ref.Builtin {
		case "any":
			return Any()
		case "string":
			return String()
		case "int":
			return Int()
		case "int64":
			return Int64()
		case "float64":
			return Float64()
		case "bool":
			return Bool()
		default:
			return Id(ref.Builtin)
		}
	}
	if ref.QualName != "" {
		return Qual(ref.Package, ref.QualName)
	}
	if ref.Named != "" {
		return Id(ref.Named)
	}
	return Any()
}

// emitUnmarshalYAML generates the UnmarshalYAML method using the type-alias trick.
func (e *Emitter) emitUnmarshalYAML(f *File, goType *GoType) {
	aliasName := "plain" + goType.Name

	// Build the method body.
	var body []Code

	// type alias = TypeName
	body = append(body, Type().Id(aliasName).Id(goType.Name))
	// x := (*alias)(v)
	body = append(body, Id("x").Op(":=").Parens(Op("*").Id(aliasName)).Parens(Id("v")))
	// if err := node.Decode(x); err != nil { return err }
	body = append(body, If(
		Err().Op(":=").Id("node").Dot("Decode").Call(Id("x")),
		Err().Op("!=").Nil(),
	).Block(
		Return(Err()),
	))

	// For types with embedded base structs (NeedsUnmarshalYAML), the
	// type-alias trick doesn't populate promoted fields from Go embeds.
	// Decode each embedded struct separately to work around this.
	for _, field := range goType.Fields {
		if field.Embed && field.Type.Named != "" && field.Name != "FileMetadata" {
			body = append(body, If(
				Err().Op(":=").Id("node").Dot("Decode").Call(Op("&").Id("v").Dot(field.Name)),
				Err().Op("!=").Nil(),
			).Block(
				Return(Err()),
			))
		}
	}

	// v.FileMetadata.line = node.Line
	body = append(body, Id("v").Dot("FileMetadata").Dot("line").Op("=").Id("node").Dot("Line"))
	// v.FileMetadata.column = node.Column
	body = append(body, Id("v").Dot("FileMetadata").Dot("column").Op("=").Id("node").Dot("Column"))
	body = append(body, Return(Nil()))

	f.Comment(fmt.Sprintf("UnmarshalYAML implements yaml.Unmarshaler for %s.", goType.Name))
	f.Comment("It captures the YAML node position for FileMetadata.")
	f.Func().Params(
		Id("v").Op("*").Id(goType.Name),
	).Id("UnmarshalYAML").Params(
		Id("node").Op("*").Qual(yamlPkg, "Node"),
	).Error().Block(body...)
	f.Line()
}

// emitEnum generates a string type and const block for enum values.
func (e *Emitter) emitEnum(f *File, goType *GoType) {
	if goType.Doc != "" {
		f.Comment(formatDocComment(goType.Name, goType.Doc))
	}
	f.Type().Id(goType.Name).String()
	f.Line()

	if len(goType.EnumValues) > 0 {
		f.Comment(fmt.Sprintf("Enum values for %s.", goType.Name))
		consts := make([]Code, len(goType.EnumValues))
		for i, ev := range goType.EnumValues {
			consts[i] = Id(ev.GoName).Id(goType.Name).Op("=").Lit(ev.Value)
		}
		f.Const().Defs(consts...)
		f.Line()
	}
}

// emitMetadata generates the metadata.go file with FileMetadata and
// annotateFileMetadata.
func (e *Emitter) emitMetadata() error {
	f := NewFile(e.pkgName)
	f.HeaderComment("Code generated by cmd/generate; DO NOT EDIT.")

	// Import reflect.
	f.ImportName("reflect", "reflect")

	// FileMetadata struct.
	f.Comment("FileMetadata records the source file location from which a value was loaded.")
	f.Type().Id("FileMetadata").Struct(
		Id("file").String().Comment("file from which value was read."),
		Id("line").Int().Comment("line from which value was read."),
		Id("column").Int().Comment("column from which value was read."),
	)
	f.Line()

	// Accessor methods.
	f.Comment("FilePath returns the file path from which the value was loaded.")
	f.Func().Params(Id("m").Id("FileMetadata")).Id("FilePath").Params().String().Block(
		Return(Id("m").Dot("file")),
	)
	f.Line()

	f.Comment("Line returns the line number in the source file.")
	f.Func().Params(Id("m").Id("FileMetadata")).Id("Line").Params().Int().Block(
		Return(Id("m").Dot("line")),
	)
	f.Line()

	f.Comment("Column returns the column number in the source file.")
	f.Func().Params(Id("m").Id("FileMetadata")).Id("Column").Params().Int().Block(
		Return(Id("m").Dot("column")),
	)
	f.Line()

	// annotateFileMetadata function.
	f.Comment("annotateFileMetadata sets the file name on any types that contain FileMetadata.")
	f.Func().Id("annotateFileMetadata").Params(
		Id("file").String(),
		Id("v").Any(),
	).Block(
		Id("fileAnnotator").Values(Dict{
			Id("name"): Id("file"),
		}).Dot("annotate").Call(Qual("reflect", "ValueOf").Call(Id("v"))),
	)
	f.Line()

	// fileAnnotator struct.
	f.Type().Id("fileAnnotator").Struct(
		Id("name").String(),
	)
	f.Line()

	// annotate method.
	f.Func().Params(Id("a").Id("fileAnnotator")).Id("annotate").Params(
		Id("val").Qual("reflect", "Value"),
	).Block(
		If(
			Id("val").Dot("CanAddr").Call().Op("&&").Id("val").Dot("CanSet").Call(),
		).Block(
			If(
				List(Id("m"), Id("ok")).Op(":=").Id("val").Dot("Addr").Call().Dot("Interface").Call().Assert(Op("*").Id("FileMetadata")),
				Id("ok"),
			).Block(
				Id("m").Dot("file").Op("=").Id("a").Dot("name"),
				Return(),
			),
		),
		Line(),
		Switch(Id("val").Dot("Kind").Call()).Block(
			Case(Qual("reflect", "Pointer")).Block(
				If(Op("!").Id("val").Dot("IsNil").Call()).Block(
					Id("a").Dot("annotate").Call(Id("val").Dot("Elem").Call()),
				),
			),
			Case(Qual("reflect", "Struct")).Block(
				For(
					Id("i").Op(":=").Lit(0),
					Id("i").Op("<").Id("val").Dot("NumField").Call(),
					Id("i").Op("++"),
				).Block(
					Id("a").Dot("annotate").Call(Id("val").Dot("Field").Call(Id("i"))),
				),
			),
			Case(Qual("reflect", "Slice")).Block(
				For(
					Id("i").Op(":=").Lit(0),
					Id("i").Op("<").Id("val").Dot("Len").Call(),
					Id("i").Op("++"),
				).Block(
					Id("a").Dot("annotate").Call(Id("val").Dot("Index").Call(Id("i"))),
				),
			),
			Case(Qual("reflect", "Map")).Block(
				Id("itr").Op(":=").Id("val").Dot("MapRange").Call(),
				For(Id("itr").Dot("Next").Call()).Block(
					Id("a").Dot("annotate").Call(Id("itr").Dot("Value").Call()),
				),
			),
		),
	)
	f.Line()

	path := filepath.Join(e.outputDir, "metadata.go")
	return f.Save(path)
}

// formatDocComment formats a Go doc comment for a type or field.
// It ensures the comment starts with the type/field name per Go convention.
func formatDocComment(name, doc string) string {
	doc = strings.TrimSpace(doc)
	if doc == "" {
		return name + " is a generated type."
	}

	// If doc already starts with the name, return as is.
	if strings.HasPrefix(doc, name+" ") || strings.HasPrefix(doc, name+".") {
		return doc
	}

	// Prepend name.
	// Ensure first character after name is lowercase unless it's an acronym.
	firstChar := ""
	if len(doc) > 0 {
		firstChar = strings.ToLower(doc[:1])
		if doc[:1] == strings.ToUpper(doc[:1]) {
			// Check if it's the start of an acronym or a sentence.
			if len(doc) > 1 && doc[1:2] == strings.ToUpper(doc[1:2]) {
				// Acronym â€” keep it uppercase.
				firstChar = doc[:1]
			}
		}
	}

	return name + " " + firstChar + doc[1:]
}
