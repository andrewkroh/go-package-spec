package sqlgen

import (
	"fmt"
	"path/filepath"
	"strings"

	. "github.com/dave/jennifer/jen"
)

const (
	pkgspecImport   = "github.com/andrewkroh/go-package-spec/pkgspec"
	dbImport        = "github.com/andrewkroh/go-package-spec/pkgsql/internal/db"
	databaseSQLPkg  = "database/sql"
	encodingJSONPkg = "encoding/json"
)

// EmitTablesGo generates tables.go with CREATE TABLE constants and a creates slice.
func EmitTablesGo(pkgName, outputDir string, tables []*TableDef) error {
	f := NewFile(pkgName)
	f.HeaderComment("Code generated by cmd/gensql; DO NOT EDIT.")

	// Individual CREATE TABLE constants (unexported).
	var constDefs []Code
	var names []string
	for _, td := range tables {
		goName := sqlNameToGoName(td.Name)
		constName := unexport(goName)
		names = append(names, constName)
		sql := generateCreateTable(td)
		constDefs = append(constDefs, Id(constName).Op("=").Lit(sql))
	}

	f.Comment("CREATE TABLE statements for each table.")
	f.Const().Defs(constDefs...)
	f.Line()

	// creates slice in dependency order (unexported).
	var sliceItems []Code
	for _, name := range names {
		sliceItems = append(sliceItems, Id(name))
	}

	f.Comment("creates contains all CREATE TABLE statements in dependency order.")
	f.Var().Id("creates").Op("=").Index().String().Values(sliceItems...)
	f.Line()

	path := filepath.Join(outputDir, "tables.go")
	return f.Save(path)
}

// EmitInsertGo generates insert.go with type→sqlc param mapping functions
// and shared helper functions.
func EmitInsertGo(pkgName, outputDir string, tables []*TableDef) error {
	f := NewFile(pkgName)
	f.HeaderComment("Code generated by cmd/gensql; DO NOT EDIT.")

	// Emit helper functions first.
	emitHelpers(f)

	// Emit per-table mapping functions.
	for _, td := range tables {
		if td.GoType == "" || td.GoType == "Processor" {
			continue
		}
		emitInsertFunc(f, td)
	}

	path := filepath.Join(outputDir, "insert.go")
	return f.Save(path)
}

// emitHelpers generates shared nullable conversion helpers.
func emitHelpers(f *File) {
	// toNullString
	f.Comment("toNullString converts a string to sql.NullString. Empty strings are NULL.")
	f.Func().Id("toNullString").Params(
		Id("s").String(),
	).Qual(databaseSQLPkg, "NullString").Block(
		Return(Qual(databaseSQLPkg, "NullString").Values(Dict{
			Id("String"): Id("s"),
			Id("Valid"):  Id("s").Op("!=").Lit(""),
		})),
	)
	f.Line()

	// toNullInt64
	f.Comment("toNullInt64 converts an int to sql.NullInt64. Zero values are NULL.")
	f.Func().Id("toNullInt64").Params(
		Id("i").Int(),
	).Qual(databaseSQLPkg, "NullInt64").Block(
		Return(Qual(databaseSQLPkg, "NullInt64").Values(Dict{
			Id("Int64"): Int64().Call(Id("i")),
			Id("Valid"): Id("i").Op("!=").Lit(0),
		})),
	)
	f.Line()

	// toNullFloat64
	f.Comment("toNullFloat64 converts a float64 to sql.NullFloat64. Zero values are NULL.")
	f.Func().Id("toNullFloat64").Params(
		Id("f").Float64(),
	).Qual(databaseSQLPkg, "NullFloat64").Block(
		Return(Qual(databaseSQLPkg, "NullFloat64").Values(Dict{
			Id("Float64"): Id("f"),
			Id("Valid"):   Id("f").Op("!=").Lit(0),
		})),
	)
	f.Line()

	// toNullBool
	f.Comment("toNullBool converts a *bool to sql.NullBool.")
	f.Func().Id("toNullBool").Params(
		Id("b").Op("*").Bool(),
	).Qual(databaseSQLPkg, "NullBool").Block(
		If(Id("b").Op("==").Nil()).Block(
			Return(Qual(databaseSQLPkg, "NullBool").Values()),
		),
		Return(Qual(databaseSQLPkg, "NullBool").Values(Dict{
			Id("Bool"):  Op("*").Id("b"),
			Id("Valid"): True(),
		})),
	)
	f.Line()

	// jsonString
	f.Comment("jsonString marshals a value to a JSON string. Returns empty string on error.")
	f.Func().Id("jsonString").Params(
		Id("v").Any(),
	).String().Block(
		If(Id("v").Op("==").Nil()).Block(
			Return(Lit("")),
		),
		List(Id("data"), Id("err")).Op(":=").Qual(encodingJSONPkg, "Marshal").Call(Id("v")),
		If(Id("err").Op("!=").Nil()).Block(
			Return(Lit("")),
		),
		Return(String().Call(Id("data"))),
	)
	f.Line()

	// jsonNullString
	f.Comment("jsonNullString marshals a value to a sql.NullString JSON column.")
	f.Func().Id("jsonNullString").Params(
		Id("v").Any(),
	).Qual(databaseSQLPkg, "NullString").Block(
		If(Id("v").Op("==").Nil()).Block(
			Return(Qual(databaseSQLPkg, "NullString").Values()),
		),
		List(Id("data"), Id("err")).Op(":=").Qual(encodingJSONPkg, "Marshal").Call(Id("v")),
		If(Id("err").Op("!=").Nil()).Block(
			Return(Qual(databaseSQLPkg, "NullString").Values()),
		),
		Id("s").Op(":=").String().Call(Id("data")),
		Return(Qual(databaseSQLPkg, "NullString").Values(Dict{
			Id("String"): Id("s"),
			Id("Valid"):  Id("s").Op("!=").Lit("").Op("&&").Id("s").Op("!=").Lit("null"),
		})),
	)
	f.Line()

	// timeNullString
	f.Comment("timeNullString converts a *time.Time to sql.NullString (RFC3339 format).")
	f.Func().Id("timeNullString").Params(
		Id("t").Op("*").Qual("time", "Time"),
	).Qual(databaseSQLPkg, "NullString").Block(
		If(Id("t").Op("==").Nil()).Block(
			Return(Qual(databaseSQLPkg, "NullString").Values()),
		),
		Return(Qual(databaseSQLPkg, "NullString").Values(Dict{
			Id("String"): Id("t").Dot("Format").Call(Qual("time", "RFC3339")),
			Id("Valid"):  True(),
		})),
	)
	f.Line()
}

// emitInsertFunc generates a function that maps a pkgspec type to sqlc InsertXParams.
func emitInsertFunc(f *File, td *TableDef) {
	goName := sqlNameToGoName(td.Name)
	funcName := "map" + goName + "Params"
	paramsType := "Insert" + goName + "Params"

	// Build parameter list.
	var funcParams []Code
	funcParams = append(funcParams, Id("v").Op("*").Qual(pkgspecImport, td.GoType))

	// Add parent ID parameter if there's a parent.
	if td.Parent != "" {
		funcParams = append(funcParams, Id("parentID").Int64())
	}

	// Add extra column parameters.
	for _, col := range td.Columns {
		if col.IsExtra && !col.PK && col.FK == "" {
			funcParams = append(funcParams, Id(toGoParamName(col.Name)).Add(extraColumnGoType(col)))
		}
	}

	// Build field assignments as a Dict.
	dict := Dict{}
	for _, col := range td.Columns {
		if col.PK {
			continue
		}

		fieldName := sqlNameToGoFieldName(col.Name)

		if col.IsExtra {
			if col.FK != "" {
				if td.Parent != "" {
					// Single parent FK: filled from parentID parameter.
					dict[Id(fieldName)] = Id("parentID")
				}
				// Multi-FK tables (no parent): FK columns are
				// excluded from the mapping function so the caller
				// sets them after calling the mapper.
			} else {
				dict[Id(fieldName)] = Id(toGoParamName(col.Name))
			}
			continue
		}

		dict[Id(fieldName)] = buildFieldAssignment(col)
	}

	f.Comment(fmt.Sprintf("%s converts a %s to db.%s.", funcName, td.GoType, paramsType))
	f.Func().Id(funcName).Params(funcParams...).Qual(dbImport, paramsType).Block(
		Return(Qual(dbImport, paramsType).Values(dict)),
	)
	f.Line()
}

// buildFieldAssignment generates the RHS expression for a field assignment
// in the insert mapping function.
func buildFieldAssignment(col ColumnDef) *Statement {
	// Method-based columns (e.g. FileMetadata getters).
	if col.IsMethod {
		call := Id("v").Dot(col.GoField).Call()
		switch col.SQLType {
		case "TEXT":
			return Id("toNullString").Call(call)
		case "INTEGER":
			return Id("toNullInt64").Call(call)
		default:
			return call
		}
	}

	goPath := "v." + col.GoField

	// Split the field path for nested access.
	parts := strings.Split(col.GoField, ".")
	accessor := Id("v")
	for _, p := range parts {
		accessor = accessor.Dot(p)
	}

	if col.IsJSON {
		return Id("jsonNullString").Call(accessor)
	}

	if col.IsPointer {
		if col.SQLType == "BOOLEAN" {
			return Id("toNullBool").Call(accessor)
		}
		if col.SQLType == "TEXT" {
			// *time.Time
			if strings.Contains(goPath, "Time") || strings.Contains(goPath, "Date") {
				return Id("timeNullString").Call(accessor)
			}
		}
		return Id("toNullBool").Call(accessor)
	}

	if col.IsEnum {
		if col.NotNull {
			return String().Call(accessor)
		}
		return Id("toNullString").Call(String().Call(accessor))
	}

	if col.NotNull {
		return accessor
	}

	// Optional non-pointer fields.
	switch col.SQLType {
	case "TEXT":
		return Id("toNullString").Call(accessor)
	case "INTEGER":
		return Id("toNullInt64").Call(accessor)
	case "REAL":
		return Id("toNullFloat64").Call(accessor)
	case "BOOLEAN":
		return accessor
	default:
		return accessor
	}
}

// extraColumnGoType returns the jennifer Code for the Go type of an extra column parameter.
// This matches what sqlc generates for the InsertXParams field type.
func extraColumnGoType(col ColumnDef) Code {
	switch col.SQLType {
	case "BOOLEAN":
		if col.NotNull {
			return Bool()
		}
		return Qual(databaseSQLPkg, "NullBool")
	case "INTEGER":
		if col.NotNull {
			return Int64()
		}
		return Qual(databaseSQLPkg, "NullInt64")
	case "REAL":
		if col.NotNull {
			return Float64()
		}
		return Qual(databaseSQLPkg, "NullFloat64")
	case "JSON":
		// sqlc maps JSON columns to interface{}.
		return Any()
	default:
		// TEXT and anything else → string / sql.NullString
		if col.NotNull {
			return String()
		}
		return Qual(databaseSQLPkg, "NullString")
	}
}

// unexport lowercases the first letter of a Go identifier to make it unexported.
func unexport(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = []rune(strings.ToLower(string(r[0])))[0]
	return string(r)
}

func toGoParamName(sqlName string) string {
	parts := strings.Split(sqlName, "_")
	var b strings.Builder
	for i, part := range parts {
		if part == "" {
			continue
		}
		if i == 0 {
			b.WriteString(part)
		} else {
			runes := []rune(part)
			runes[0] = []rune(strings.ToUpper(string(runes[0])))[0]
			b.WriteString(string(runes))
		}
	}
	return b.String()
}

// sqlNameToGoFieldName converts a SQL column name to the sqlc-generated
// Go field name (PascalCase). This matches sqlc's naming convention exactly:
// simple title case for each underscore-separated segment, with "id" → "ID"
// as the only abbreviation.
func sqlNameToGoFieldName(sqlName string) string {
	parts := strings.Split(sqlName, "_")
	var b strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		// sqlc only special-cases "id" → "ID".
		if strings.EqualFold(part, "id") {
			b.WriteString("ID")
		} else {
			runes := []rune(part)
			runes[0] = []rune(strings.ToUpper(string(runes[0])))[0]
			b.WriteString(string(runes))
		}
	}
	return b.String()
}
